{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#crisp-cartesian-impedance-and-operational-space-control-for-learning-based-policies","title":"CRISP - CaRtesian Impedance and Operational Space Control for Learning-based Policies","text":"<p>Authors: Daniel San Jose Pro, Oliver Hausdoerfer, Ralf Roemer, Martin Schuck and Angela Schoellig.</p> <p>Collection of C++ controllers for torque-based control for manipulators compatible with <code>ros2_control</code>, including Operational Space Control and Cartesian Impedance Control. </p> <p>Check the controllers (crisp_controllers)  , robot demos (crisp_controllers_demos) , a simple python interface (crisp_py) , and a gym wrapper (crisp_gym)  for real-world experiments.</p> Recording trajectories with crisp_gym  (video speed x1). Diffusion Policy trained deployed from the same demonstrations (video speed x1). Robot following a moving target, while base joint follows a sine curve. Simulated kinova robot with continous joints and nullspace control Another simulated robot example... Real robot following a target and being disturbed (contact) + null space control demonstration Demonstration using a cartesian controller teleoperated using Vicon tracking system (video speed x4)"},{"location":"#why","title":"Why?","text":"<p>Learning-based controllers, such as diffusion policies, deep reinforcement learning, and vision-action-models in general, typically output low-frequency or sporadic target poses, necessitating a low-level controller to track these references smoothly, especially in contact-rich environments. While <code>ROS2</code> frameworks like <code>MoveIt</code> offer comprehensive motion planning capabilities, they are often unnecessarily complex for tasks requiring simple, real-time pose or joint servoing.</p> <p>We present a set of lightweight, torque-based Cartesian and joint-space controllers implemented in C++ for <code>ros2_control</code>, compatible with any robot exposing an effort interface\u2014a common standard among modern manipulators. Our controllers incorporate friction compensation, joint limit avoidance, and error clipping, and have been validated on the Franka Robotics FR3 manipulator.</p> <p>Designed for fast integration and real-time control, our implementation lowers the barrier to deploying learning-based algorithms on <code>ROS2</code>-compatible platforms.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udd16 Cartesian Impedance Controller as well as Operational Space Controller for torque-based control.  </li> <li>\ud83d\udeab No MoveIt or complicated path-planning, just a simple C++ <code>ros2_controller</code>. Ready to use.  </li> <li>\u2699\ufe0f Dynamically and highly parametrizable: powered by the <code>generate_parameter_library</code> you can modify stiffness and more during operation.  </li> <li>\ud83d\udc0d Python interface to move your ROS2 robot around without having to think about topics, spinning, and more ROS2 concepts but without loosing the powerful ROS2 API. Check crisp_py  for more information and examples.</li> <li>\ud83d\udd01 Gym environment with utilities to record trajectories in LeRobotFormat and deploy trained policies. Check crisp_gym .</li> <li>\u2753 Demos showcasing how to use the controller with FR3 of Franka Emika in single and bimanual setup. Check the crisp_controller_demos .</li> </ul>"},{"location":"#citing","title":"Citing","text":"<pre><code>@inproceeding{\n   TODO\n}\n</code></pre>"}]}