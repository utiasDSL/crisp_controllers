{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#crisp-ros2-compatible-compliant-controllers-for-learning-based-manipulation","title":"CRISP - ROS2 compatible Compliant Controllers for Learning-based Manipulation","text":"<p>Authors: Daniel San Jose Pro, Oliver Hausd\u00f6rfer, Ralf R\u00f6mer, Martin Schuck and Angela Sch\u00f6llig.</p> <p>Collection of C++ controllers for torque-based control for manipulators compatible with <code>ros2_control</code>, including Operational Space Control and Cartesian Impedance Control. Developed for deploying high-level learning-based policies (VLA, Diffusion, ...).</p> <p>If you use this work, please cite it using below bibtex.</p> <p>Check the controllers (CRISP controllers)  , robot demos (CRISP controllers demos) , a simple python interface (CRISP_PY) , and a gym wrapper (CRISP_GYM)  for real-world experiments.</p> Robot teleoperated using a Follower-Leader system in CRISP GYM  Diffusion Policy trained and deployed from the same demonstrations. Robot following a moving target, while base joint follows a sine curve. Simulated kinova robot with continous joints and nullspace control Simulated iiwa robot example... Real robot following a target and being disturbed (contact) + null space control demonstration Demonstration using a cartesian controller teleoperated using Vicon tracking system (Speed x4)"},{"location":"#why","title":"Why?","text":"<p>Learning-based controllers, such as diffusion policies, deep reinforcement learning, and vision-action-models in general, typically output low-frequency or sporadic target poses, necessitating a low-level controller to track these references smoothly, especially in contact-rich environments. While <code>ROS2</code> frameworks like <code>MoveIt</code> offer comprehensive motion planning capabilities, they are often unnecessarily complex for tasks requiring simple, real-time pose or joint servoing.</p> <p>We present a set of lightweight, torque-based Cartesian and joint-space controllers implemented in C++ for <code>ros2_control</code>, compatible with any robot exposing an effort interface\u2014a common standard among modern manipulators. Our controllers incorporate friction compensation, joint limit avoidance, and error clipping, and have been validated on the Franka Robotics FR3 manipulator.</p> <p>Designed for fast integration and real-time control, our implementation lowers the barrier to deploying learning-based algorithms on <code>ROS2</code>-compatible platforms.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udd16 Operational Space Controller as well as Cartesian Impedance Controller for torque-based control.  </li> <li>\ud83d\udeab No MoveIt or complicated path-planning, just a simple C++ <code>ros2_controller</code>. Ready to use.  </li> <li>\u2699\ufe0f Dynamically and highly parametrizable: powered by the <code>generate_parameter_library</code> you can modify stiffness and more during operation.  </li> <li>\ud83d\udc0d Python interface to move your ROS2 robot around without having to think about topics, spinning, and more ROS2 concepts but without loosing the powerful ROS2 API. Check crisp_py for more information and examples.</li> <li>\ud83d\udd01 Gym environment with utilities to record trajectories in LeRobotFormat and deploy trained policies. Check crisp_gym.</li> <li>\u2753 Demos showcasing how to use the controller with FR3 of Franka Emika in single and bimanual setup. Check the crisp_controller_demos.</li> </ul>"},{"location":"#citing","title":"Citing","text":"<pre><code>@inproceeding{\n   TODO\n}\n</code></pre>"}]}